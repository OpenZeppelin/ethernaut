{
    "sourceFile": "client/src/utils/ethutil.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1710382732513,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1710382732513,
            "name": "Commit-0",
            "content": "import * as ethjs from 'ethereumjs-util';\nimport TruffleContract from '@truffle/contract';\nimport * as constants from \"../constants.js\";\nimport { NETWORKS_INGAME } from '../constants.js'\n\nlet web3;\nlet duplicateTransactions = new Map();\n\nexport const setWeb3 = (_web3) => {\n  web3 = _web3;\n}\n\nexport const getWeb3 = () => web3;\n\nexport const getTruffleContract = (jsonABI, defaults = {}) => {\n  // // HACK: Doing this here instead of `import` so that the project uses the web3.js version\n  // // defined in `package.json` instead of relying on Truffle dependencies (that use an old version).\n  // // With this, MetaMask v9 deprecation warnings are removed. \n  // const TruffleContract = require('@truffle/contract');\n\n  const truffleContract = TruffleContract(jsonABI);\n  if (!defaults.gasPrice) defaults.gasPrice = 2000000000;\n  if (!defaults.gas) defaults.gas = 2000000;\n  truffleContract.defaults(defaults);\n  truffleContract.setProvider(web3.currentProvider);\n  return truffleContract;\n}\n\nexport const getBalance = (address) => {\n  return new Promise(function (resolve, reject) {\n    web3.eth.getBalance(address, function (error, result) {\n      if (error) reject(error)\n      else resolve(web3.utils.fromWei(result, 'ether'))\n    })\n  })\n}\n\nexport const getBlockNumber = () => {\n  return new Promise((resolve, reject) => {\n    web3.eth.getBlockNumber((err, blockNumber) => {\n      if (err) reject(err)\n      resolve(blockNumber);\n    });\n  });\n}\n\nexport const sendTransaction = (options) => {\n  return new Promise((resolve, reject) => {\n    web3.eth.sendTransaction(options, (err, res) => {\n      if (err) reject(err)\n      else resolve(res)\n    })\n  })\n}\n\nexport const getNetworkId = () => {\n  return new Promise((resolve, reject) => {\n    web3.eth.net.getId((err, netId) => {\n      if (err) reject();\n      else resolve(netId);\n    });\n  });\n}\n\nexport const toWei = (ether) => {\n  return web3.utils.toWei(ether, 'ether')\n}\n\nexport const fromWei = (wei) => {\n  return web3.utils.fromWei(wei, 'ether')\n}\n\nexport const watchAccountChanges = (callback, lastKnownAccount) => {\n  let interval = setInterval(function () {\n    web3.eth.getAccounts(function (error, accounts) {\n      if (error) return console.log(error)\n      const newAccount = accounts[0]\n      if (newAccount !== lastKnownAccount) {\n        callback(newAccount)\n        clearInterval(interval)\n        this.watchAccountChanges(callback, newAccount);\n      }\n    })\n  }, 1000)\n}\n\nexport const watchNetwork = (callbacks) => {\n\n  // Gas price\n  if (callbacks.gasPrice) {\n    const gasPrice = function () {\n      web3.eth.getGasPrice(function (error, result) {\n        if (error) return console.log(error)\n        callbacks.gasPrice(result)\n      })\n    }\n    gasPrice()\n    setInterval(gasPrice, 30 * 60000)\n  }\n\n  // Network id\n  if (callbacks.networkId) {\n    const netId = function () {\n      web3.eth.net.getId(function (error, result) {\n        if (error) return console.log(error)\n        callbacks.networkId(result)\n      })\n    }\n    netId()\n    setInterval(netId, 5 * 1000)\n  }\n\n  // Block num\n  if (callbacks.blockNum) {\n    const blockNum = function () {\n      web3.eth.getBlockNumber((err, blockNumber) => {\n        if (err) console.log(err)\n        callbacks.blockNum(blockNumber);\n      });\n    }\n    blockNum()\n    setInterval(blockNum, 10 * 1000)\n  }\n\n}\n\nexport const validateAddress = (address) => {\n  if (!address) return false;\n  if (address === '0x0000000000000000000000000000000000000000') return false;\n  if (address.substring(0, 2) !== \"0x\") return false;\n\n  // Basic validation: length, valid characters, etc\n  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) return false;\n\n  // Checksum validation.\n  const raw = address.replace('0x', '');\n  const allLowerCase = raw.toLowerCase() === raw;\n  const allUppercase = raw.toUpperCase() === raw;\n  if (allLowerCase || allUppercase) {\n    return true; // accepts address with no checksum data\n  }\n  else {\n    const checksum = ethjs.toChecksumAddress(address);\n    if (address !== checksum) return false;\n  }\n\n  return true;\n}\n\nexport const addressHasChecksum = (address) => {\n  if (!module.exports.isValidAddress(address)) return false;\n  const raw = address.replace('0x', '');\n  const allLowerCase = raw.toLowerCase() === raw;\n  const allUppercase = raw.toUpperCase() === raw;\n  return !(allLowerCase || allUppercase);\n}\n\nexport const verifySignature = (json) => {\n  try {\n    const messageHash = ethjs.hashPersonalMessage(ethjs.toBuffer(json.msg));\n    const signedMessageDecoded = ethjs.fromRpcSig(json.sig);\n    const recoveredPublicKey = ethjs.ecrecover(messageHash, signedMessageDecoded.v, signedMessageDecoded.r, signedMessageDecoded.s);\n    const recoveredAddressBuffer = ethjs.pubToAddress(recoveredPublicKey);\n    const recoveredAddress = ethjs.bufferToHex(recoveredAddressBuffer);\n    return json.address === recoveredAddress;\n  }\n  catch (err) {\n    return false;\n  }\n}\n\nexport const signMessageWithMetamask = (addr, message, callback) => {\n  const msg = ethjs.bufferToHex(new Buffer(message, 'utf8'));\n  web3.currentProvider.sendAsync({\n    method: 'personal_sign',\n    params: [msg, addr],\n    addr\n  }, function (err, res) {\n    callback({\n      address: addr,\n      msg: message,\n      sig: res.result,\n      version: '2'\n    });\n  });\n}\n\nexport const logger = (req, res, next, end) => {\n  next((cb) => {\n    // HACK: do not log known error when setting event log filters\n    if (res.error && !res.error.message.includes(\"TypeError: Cannot read property 'filter' of undefined\")) {\n      console.error('Error in RPC response:\\n', res.error.message);\n    } else if (req.method === 'eth_sendTransaction') {\n      console.mineInfo('Sent transaction', res.result);\n    } else if (req.method === 'eth_getTransactionReceipt' && res.result) {\n      if (duplicateTransactions.size > 1000) duplicateTransactions.clear()\n      if (!duplicateTransactions.get(res.result.transactionHash)) {\n        duplicateTransactions.set(res.result.transactionHash, true);\n        console.mineInfo('Mined transaction', res.result.transactionHash);\n      }\n    }\n    cb();\n  })\n}\n\nexport const attachLogger = () => {\n  if (web3.currentProvider._rpcEngine) {\n    web3.currentProvider._rpcEngine._middleware.unshift(logger);\n    return;\n  }  //If the current provider hasn't an RPC Engine look for other providers\n  else if (web3.currentProvider.providers) {\n    var providers = web3.currentProvider.providers;\n    for (var i = 0; i < providers.length; i++) {\n      if (providers[i]._rpcEngine) {\n        providers[i]._rpcEngine._middleware.unshift(logger);\n\n        // Set this provider as current provider\n        web3.currentProvider = providers[i];\n        return;\n      }\n    }\n  }\n\n  //If still there's no RPC Engine throw error\n  console.error(\"Can't find a valid provider, make sure you have Metamask installed and that any other wallet plugin is disabled\");\n  return;\n}\n\nexport const getGasFeeDetails = async (network, multiplier) => {\n  if (constants.SUPPORTS_EIP_1559.includes(network.networkId.toString())) {\n    const maxPriorityFeePerGas = network.web3.utils.toWei('2.5', 'gwei');\n    const block = await network.web3.eth.getBlock('latest')\n    const blockBaseFee = block.baseFeePerGas ? block.baseFeePerGas : 1;\n    return {\n      maxPriorityFeePerGas,\n      maxFeePerGas: multiplier * Number(blockBaseFee) + Number(maxPriorityFeePerGas)\n    }\n  } else {\n    const gasPrice = await network.web3.eth.getGasPrice()\n    return {\n      gasPrice: multiplier * gasPrice\n    }\n  }\n}\n\nexport const getNetworkFromId = (networkId) => {\n  const networkObjectsList = Object.values(NETWORKS_INGAME);\n  for (let network of networkObjectsList)\n    if (network && network.id === networkId.toString())\n      return network;\n}\n\nexport const getNetworkNamefromId = (networkId) => {\n  const network = getNetworkFromId(networkId);\n  return network.name\n}\n"
        }
    ]
}